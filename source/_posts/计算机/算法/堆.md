---
title: 堆
categories:
  - 计算机
  - 算法
mathjax: true
abbrlink: 21992
date: 2022-08-30 20:13:10
---
堆是一种完全二叉树. 即, 除了最后一层都是满的, 且所有节点尽量靠左.
```
            11
          /    \
         10     7
        / \    / \
       9   5  6   4
      /\  /\
     8  2 3 1
```
按列表存储更省空间: `[11, 10, 7, 9, 5, 6, 4, 8, 2, 3, 1]`.

<!--more-->

`left = parent * 2 + 1`, `right = parent * 2 + 2`, `parent = (child - 1) // 2`

**小根堆**: 每个节点都比孩子小.

**大根堆**: 每个节点都比孩子大.

以小根堆为例:

## sift up
```py
def sift_up(array, index):
    parent_idx = (index - 1) // 2
    # root or already min heap
    if parent_idx < 0 or array[index] > array[parent_idx]:  
        return
    array[index], array[parent_idx] = array[parent_idx], array[index]
    sift_up(array, parent_idx)
```
时间: $O(\log n)$

空间: $O(\log n)$

## sift down

```py
def sift_down(array, index):
    left = index * 2 + 1
    right = left + 1
    small = index
    # have left and left smaller
    if left < len(array) and array[left] < array[small]:
        small = left
    # have right and right smaller
    if right < len(array) and array[right] < array[small]:
        small = right
    # need to swap
    if small != index:
        array[small], array[index] = array[index], array[small]
        sift_down(array, small)
```
时间: $O(\log n)$

空间: $O(\log n)$

## 初始化

```py
def build_heap(arr):
    # start from the parent of last leaf, end at root
    for i in range(len(arr)//2 - 1, -1, -1):
        sift_down(arr, i)
```
时间: $O(n)$

这是因为不是每次都需要 $\log n$ 的复杂度, 它与节点的深度有关. 

$0\times n/2 + 1\times n/4 + 2\times n/8 + \cdots + \log n \times 1=O(n)$.

## 实现
```py
class Heap:
    def __init__(self):
        self.array = []

    def push(self, val):
        self.array.append(val)
        sift_up(self.array, len(self.array)-1)

    def pop(self):
        res = self.array[0]
        self.array[0], self.array[-1] = self.array[-1], self.array[0]
        self.array.pop()
        sift_down(self.array, 0)
        return res
```

## 前 k 小的数据
step 1: 取前 k 个值放入大根堆.

step 2: 对剩余值, 与大根堆的堆顶比. 

- 若比堆顶大, 忽略;
- 若比堆顶小, 去堆顶, 加入该值.

时间: $O\left(k+(n-1)\log k\right)$

```py
import heapq
def kSmallest(array):
    if not array:
        return array
    if len(array) <= k:
        return array
    res = [-i for i in array[:k]]
    heapq.heapify(res)
    for i in range(k, len(array)):
        if array[i] < -res[0]:
            heapq.heappop(res)
            heapq.heappush(res, -array[i])
    return [-i for i in res]
```