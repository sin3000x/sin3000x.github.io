---
title: 二叉树的一些遍历
categories:
  - 计算机
  - 算法
tags:
  - 树
mathjax: true
abbrlink: 47437
date: 2022-08-11 20:16:59
---
```py
class TreeNode:
    def __init__(self, val) -> None:
        self.val = val
        self.left = None
        self.right = None
```

<!--more-->

## 先序 Pre-order: val, left, right

```py
def preorder(root):
    if root is None:
        return
    print(root.val, end=' ')
    preorder(root.left)
    preorder(root.right)
```
时间: $O(n)$

空间: $O(h)$, $h$ 是树的高度

## 中序/根序 In-order: left, val, right

```py
def inorder(root):
    if root is None:
        return
    inorder(root.left)
    print(root.val)
    inorder(root.right)
```

## 后序 Post-order: left, right, val

```py
def postorder(root):
    if root is None:
        return
    postorder(root.left)
    postorder(root.right)
    print(root.val)
```

## 获取高度
```py
def get_height(root):
    if root is None:
        return 0
    left = get_height(root.left)
    right = get_height(root.right)
    return max(left, right) + 1
```
时间: $O(n)$

空间: $O(h)$

## 获取节点数
```py
def get_sum(root):
    if root is None:
        return 0
    left = get_sum(root.left)
    right = get_sum(root.right)
    return left + right + 1
```

## 按行打印
```py
from collections import deque
def print_by_row(root):
    q = deque()
    q.append(root)
    while q:
        head = q.popleft()
        print(head.val, end=' ')
        if head.left:
            q.append(head.left)
        if head.right:
            q.append(head.right)
```

## 按行打印, 中途要求回车

```py
def print_by_row2(root):
    cur = deque([root])
    next = deque()
    while cur:
        head = cur.popleft()
        print(head.val, end=' ')
        if head.left:
            next.append(head.left)
        if head.right:
            next.append(head.right)
        
        if not cur:
            print()
            if next:
                cur, next = next, deque()
```

## 非递归遍历

```py
stack = [(root, 1)]
while stack:
    node, count = stack.pop()

    if count == 1:
        print(node.val)  # 更改这一句以实现三种顺序
        stack.append((node, count + 1))
        if node.left:
            stack.append((node.left, 1))

    if count == 2:
        stack.append((node, count + 1))
        if node.right:
            stack.append((node.right, 1))

    if count == 3:
        continue
```