---
title: 二分查找
categories:
  - 计算机
  - 算法
mathjax: true
abbrlink: 42877
description: 二分查找的原始与变种问题.
date: 2022-08-06 15:33:39
---
## 原始问题: 找到返回下标, 找不到返回空
```py
def binary_search(array, target):
    if not array:
        return None
        
    left, right = 0, len(array)-1
    while left <= right:
        mid = (left + right) // 2
        if array[mid] > target:
            right = mid - 1
        elif array[mid] < target:
            left = mid + 1
        else:
            return mid
    return None
```
时间: $O(\log N)$

空间: $O(1)$

## 变种: 有序矩阵
比如在下面的矩阵中找 10
```
1  2  3  4
5  6  7  8
9  10 11 12
```
应该返回 `(2, 1)`. 设矩阵是 `M*N` 的.

关键就在于压平后的下标和行标, 列标之间的关系.

- `idx = row_idx * N + col_idx`
- `row_idx = idx // N`
- `col_idx = idx % N`

```py
def binary_search_2d(matrix, target):
    if not matrix:
        return None
    M, N = len(matrix), len(matrix[0])
    left, right = 0, M*N-1
    while left <= right:
        mid = (left + right) // 2
        row = mid // N
        col = mid % N
        if matrix[row][col] > target:
            right = mid - 1
        elif matrix[row][col] < target:
            left = mid + 1
        else:
            return (row, col)
    return None
```
时间: $\log(MN)$

## 变种: 找最近的数
比如在 `[1, 2, 5, 9]` 中找 `3`, 应该返回下标 `1`.
```py
def find_closest(array, target):
    if not array:
        return None
    left, right = 0, len(array)-1
    while left < right - 1:
        mid = (left + right) // 2
        if array[mid] > target:
            right = mid
        elif array[mid] < target:
            left = mid
        else:
            return mid
    return left if abs(target - array[left]) < abs(target - array[right]) else right
```

## 变种: 找第一次出现的下标
```py
def find_first(array, target):
    if not array:
        return None
    left, right = 0, len(array)-1
    while left < right - 1:
        mid = (left + right) // 2
        if array[mid] > target:
            right = mid - 1
        elif array[mid] < target:
            left = mid + 1
        else:
            right = mid
    if array[left] == target:
        return left
    if array[right] == target:
        return right
    return None
```

## 变种: 找最后一次出现的下标
```py
def find_last(array, target):
    if not array:
        return None
    left, right = 0, len(array)-1
    while left < right - 1:
        mid = (left + right) // 2
        if array[mid] > target:
            right = mid - 1
        elif array[mid] < target:
            left = mid + 1
        else:
            left = mid
    if array[right] == target:
        return right
    if array[left] == target:
        return left
    return None
```