---
title: 排序
categories:
  - 计算机
  - 算法
mathjax: true
abbrlink: 37489
date: 2022-08-05 20:59:15
description: 冒泡, 选择, 插入, 归并, 快速排序.
---
## 冒泡排序 (bubble sort)
### 解法一
```py
def bubble_sort1(array):
    # 每次都排好最后一个元素, 所以关注的列表长度 (n) 依次少 1
    for n in range(len(array)-1, 0, -1):    
        # 从左到右比较, 把最大的数串到最右边
        for i in range(n):
            if array[i] > array[i+1]:
                array[i], array[i+1] = array[i+1], array[i]
```
### 解法二
```py
def bubble_sort2(array):
    for n in range(len(array)):
        for i in range(len(array)-n-1):
            if array[i] > array[i+1]:
                array[i], array[i+1] = array[i+1], array[i]
```
时间: $O(n^2)$

空间: $O(1)$

## 选择排序 (selection sort)
### 解法一
```py
def selection_sort1(array):
    # 每次都排好最后一个元素, 所以关注的列表长度 (n) 依次少 1
    for n in range(len(array)-1, 0, -1):
        # 找到当前窗口的最大元素
        max_ind = 0
        for i in range(n+1):
            if array[i] > array[max_ind]:
                max_ind = i
        # 把它和当前最后一个元素交换
        array[n], array[max_ind] = array[max_ind], array[n]
```
### 解法二
```py
def selection_sort2(array):
    # 每次都排好第一个元素, 从第 i 个开始看
    for i in range(len(array)):
        # 找到最小元素
        min_ind = i
        for j in range(i, len(array)):
            if array[j] < array[min_ind]:
                min_ind = j
        # 和第一个元素交换
        array[i], array[min_ind] = array[min_ind], array[i]
```
时间: $O(n^2)$

空间: $O(1)$

## 插入排序 (insertion sort)
### 方法一
```py
def insert_num(array, num):
    """
    insert num into array, while keeping array sorted
    """
    array.append(num)
    idx = len(array)-1
    while idx > 0:
        if array[idx-1] > array[idx]:
            array[idx-1], array[idx] = array[idx], array[idx-1]
        else:
            break
        idx -= 1

def insertion_sort(array):
    new = []
    for num in array:
        insert_num(new, num)
    return new
```
时间: $O(n^2)$

空间: $O(n)$

### 方法二
```py
def insertion_sort2(array):
    # i 之后的是没见过的数, i 之前的是插入排好的
    for i in range(1, len(array)):
        k = i   # 要插入的数
        # 插入下标 k 的数
        while k > 0:
            if array[k-1] > array[k]:
                array[k-1], array[k] = array[k], array[k-1]
            else:
                break
            k -= 1
```
时间: $O(n^2)$

空间: $O(1)$

## 归并排序 (merge sort)
```python
def merge(l1, l2):
    new = []
    i = j = 0
    while i < len(l1) and j < len(l2):
        if l1[i] < l2[j]:
            new.append(l1[i])
            i += 1
        else:
            new.append(l2[j])
            j += 1
    if i < len(l1):
        new.extend(l1[i:])
    if j < len(l2):
        new.extend(l2[j:])
    return new
```
时间: $O(n)$

空间: $O(n)$

```python
def merge_sort(array):
    if len(array) in (0, 1):
        return array
    mid = (len(array) + 1) // 2
    left = merge_sort(array[:mid])
    right = merge_sort(array[mid:])
    return merge(left, right)
```
时间: $O(n\log n)$

空间: $O(\log n)+O(n)=O(n)$ 

recursion 层数 + 最多同时用到的空间

## 快速排序 (quick sort)

```python
def partition(array, start, end, pivot_ind):
    array[pivot_ind], array[end] = array[end], array[pivot_ind]
    store = start  # store 左边都比 pivot 小
    pivot = array[end]
    for i in range(start, end):
        if array[i] < pivot:
            array[i], array[store] = array[store], array[i]
            store += 1
    array[store], array[end] = array[end], array[store]
    return store
```
时间: $O(n)$

空间: $O(1)$
```python
from random import randrange
def helper(array, start, end):
    if start >= end:
        return
    pivot_ind = randrange(start, end + 1)
    new_pivot_ind = partition(array, start, end, pivot_ind)
    helper(array, start, new_pivot_ind - 1)
    helper(array, new_pivot_ind + 1, end)

def quick_sort(array):
    helper(array, 0, len(array)-1)
```
快速排序是不稳定的.

时间: 

- $O(n\log n)$ (理想情况, pivot 取中位数)
- $O(n^2)$ (最差情况, pivot 取最值)

空间: 

- $O(\log n)$ (平均情况)
- $O(n)$ (小概率)