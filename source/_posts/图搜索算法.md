---
title: 图搜索算法
categories:
  - 计算机
  - 算法
mathjax: true
abbrlink: 29510
date: 2022-09-19 20:15:58
description: BFS 和 DFS.
---
# BFS

## 之字形遍历树

```
   3
  / \
 9  20
    /\
   15 7   
```
返回 `[[3], [20,9], [15,7]]`.

```py
def zigzag(root):
    if not root:
        return []
    frontier = [root]
    reverse = False
    ans = []

    while frontier:
        next, cur = [], []
        # next 存储邻域节点, cur 存储当前层的值
        for u in frontier:
            cur.append(u.val)
            if u.left:
                next.append(u.left)
            if u.right:
                next.append(u.right)
        ans.append(cur[::-1] if reverse else cur)
        frontier = next
        reverse = not reverse
    return ans
```

## 岛屿数量
```
11110
11010
11000
00000
```
其中 1 代表陆地, 0 代表水. 返回岛屿数量, 即 1.

```py
def BFS(grid, r, c, marked):
    """
    (r, c) is the starting point
    """
    # delta row and col
    dr, dc = [-1, 0, 1, 0], [0, 1, 0, -1]
    marked.add((r, c))
    frontier = [(r, c)]
    while frontier:
        next = []
        for r, c in frontier:
            for d in range(4):
                nr, nc = r + dr[d], c + dc[d]
                if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) \
                  and grid[nr][nc] == '1' and (nr, nc) not in marked:
                    marked.add((nr, nc))
                    next.append((nr, nc))
        frontier = next

def numIslands(grid):
    res = 0
    marked = set()
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] == '1' and (r, c) not in marked:
                BFS(grid, r, c, marked)
                res += 1
    return res
```

## 单词变换
从 `hit` 变成 `cog`, 每次只变一个字符, 要求过程单词在列表 `[hot, dot, dog, lot, log, cog]` 中.

返回最短的变换路径长度 (5): `hit - hot - dot - dog - cog`.
```py
import string

def ladder_length(begin, end, words):
    words = set(words)
    if end not in words:
        return 0
    
    ans = 1
    frontier = [begin]
    used = set(frontier)

    while frontier:
        next = []
        for word in frontier:
            for p in range(len(word)):
                for c in string.ascii_lowercase:
                    new_word = word[:p] + c + word[p+1:]
                    if new_word == end:
                        return ans + 1
                    if new_word in words and new_word not in used:
                        used.add(new_word)
                        next.append(new_word)
        frontier = next
        ans += 1
    return 0

print(ladder_length('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog']))
```

## 路径填充
```
INF  -1   0   INF
INF  INF INF  -1
INF  -1  INF  -1
0    -1  INF  INF
```
INF 表示空房间, -1 表示墙, 0 表示门.

需要把 INF 都填充为走到最近的门的路径长度, 若没有路径还填 INF. 返回
```
3 -1  0  1
2  2  1 -1
1 -1  2 -1
0 -1  3  4
```

```py
def walls_and_gates(rooms):
    if not rooms:
        return
    dr, dc = [-1, 0, 1, 0], [0, 1, 0, -1]
    N, C = len(rooms), len(rooms[0])
    frontier = [(r, c) for r in range(N) for c in range(C) if rooms[r][c] == 0]
    INF = 2147483647
    dist = 0

    while frontier:
        next = []
        for r, c in frontier:
            for d in range(4):
                nr, nc = r + dr[d], c + dc[d]
                if 0 <= nr < N and 0 <= nc < C \
                    and rooms[nr][nc] == INF:
                    rooms[nr][nc] = dist + 1
                    next.append((nr, nc))
        frontier = next
        dist += 1
```

# DFS

## 检查是否有圈
```py
def dfs(directed_graph, visit_status, u):
    # 0 表示还在访问, 1 表示访问结束
    visit_status[u] = 0
    for v in directed_graph[u]:
        if v not in visit_status:
            if dfs(directed_graph, visit_status, v):
                return True
        elif visit_status[v] == 0:
            return True
    visit_status[u] = 1
    return False

def has_cycle(directed_graph):
    visit_status = {}
    for v in directed_graph:
        if v not in visit_status and dfs(directed_graph, visit_status, v):
            return True
    return False
```

## 拓扑排序

从任意节点出发, 遍历邻居, 直到遍历结束, 把邻居放入结果. 再把自己放入结果. 最后反转结果.

```py
courses = []
visited = [-1] * num

def dfs(u):
    visited[u] = 0
    for v in graph[u]:
        if visited[v] == 0 or (visited[v] == -1 and not dfs(v)):
            return False
    visited[u] = 1
    courses.append(u)
    return True

for u in range(num):
    if visited[u] == -1 and not dfs(u):
      return []

courses.reverse()
```